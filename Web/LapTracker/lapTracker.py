from django.conf import settings
import cv2
import matplotlib
matplotlib.use('Agg')

import matplotlib.pyplot as plt
from matplotlib.figure import Figure
import numpy

from skimage.metrics import structural_similarity
import os

import datetime

import csv

import threading
import ctypes
import time

from Web.models import Track, Car, TrainingSession, TrainingSessionDetails

class LapTracker(threading.Thread):


    #lapTracker settings
    raspberryCamera = False  # True using the raspberry camera
    minimumLapTime = 2  # Minimum lap time in seconds
    initialConfigTime = 2  # Minimum time for initial calibration in seconds
    videoDevice = 0  # ID of the camera used by the system
    finalImageSize = (1024, 768)  # Size of the final image generated by the demo

    #Calculated values
    cameraFPS = 30  # FPS of the camera
    circuitDistance = 12  # distance of the track in meters


    saveCSV = settings.BASE_DIR + settings.STATIC_URL + "sessions/" + str(datetime.datetime.now()) + ".csv"
    saveImg = settings.BASE_DIR + settings.STATIC_URL + "sessions/"

    cap = None
    def __init__(self, car=None, track=None):


        self.circuitDistance = float(track.length)

        # Start the camera
        self.initialCameraSettings()

        #Calculate FPS
        self.calculateFPS()


        #Saving functions
        if not os.path.exists(settings.BASE_DIR + settings.STATIC_URL + "sessions/"):
            os.mkdir(settings.BASE_DIR + settings.STATIC_URL )
            os.mkdir(settings.BASE_DIR + settings.STATIC_URL  + "sessions/")
           

        self.saveCSV = settings.BASE_DIR + settings.STATIC_URL + "sessions/"+str(car.name)+"_" + str(datetime.datetime.now()) + ".csv"

        settings.CURRENT_FILE_NAME = self.saveCSV

        #Session functions
        thisSession = TrainingSession(track=track, car=car)
        thisSession.save()

        self.trainingSession = thisSession

        #Create initial Plot
        self.createPlot([],[])

        threading.Thread.__init__(self)


    def calculateFPS(self):

        # Number of frames to capture
        num_frames = 60;

        # Start time
        start = time.time()

        # Grab a few frames
        for i in range(num_frames):
            self.getImage()

        # End time
        end = time.time()

        # Time elapsed
        seconds = end - start

        # Calculate frames per second
        self.cameraFPS = num_frames / seconds;


    def initialCameraSettings(self):
        if self.raspberryCamera:

            from picamera.array import PiRGBArray
            from picamera import PiCamera

            # initialize the camera and grab a reference to the raw camera capture
            camera = PiCamera()
            camera.resolution = (640,480)
            self.rawCapture = PiRGBArray(camera, size=(640, 480))

            # allow the camera to warmup
            time.sleep(0.1)
            self.piCamera = camera

        else:
            self.cap = cv2.VideoCapture(self.videoDevice)

    def getImage(self):

        if self.raspberryCamera:

            # capture frames from the camera
            for frame in self.piCamera.capture_continuous(self.rawCapture, format="bgr", use_video_port=True):
                # grab the raw NumPy array representing the image, then initialize the timestamp
                image = frame.array
                self.rawCapture.truncate(0)
                return image


        else:
            ret, frame = self.cap.read()
            return frame

    def stopCamera(self):

        if self.raspberryCamera:
            pass
        else:
            self.cap.release()


    def run(self):
        # target function of the thread class
        try:
            # with open(self.saveCSV, mode='w') as csvLapTime:
            #     writer = csv.writer(csvLapTime, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            #     writer.writerow(['Date', 'Lap Number', 'Lap Time (s)', "Speed (Km/h)"])

            # cap.set(cv2.CAP_PROP_AUTOFOCUS, 0) # turn the autofocus off

            # cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0) # set auto exposure

            firstImage = []

            initialConfig = False
            currentFrame = 0
            lap = 0
            isCurrentLap = False
            isCurrentLapCounter = 0
            previousLapTime = datetime.datetime.now()

            lapTimesInSeconds = []
            speeds = []

            while (not settings.STOP_THREAD):

                # Capture frame-by-frame
                frame = self.getImage()

                # create display image and copy the captured frame to it
                image = numpy.zeros((self.finalImageSize[1], self.finalImageSize[0]), numpy.uint8)

                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

                if len(firstImage) > 0 and initialConfig:
                    (score, diff) = structural_similarity(frame, firstImage, full=True)
                    diff = (diff * 255).astype("uint8")
                    final = cv2.threshold(diff, 0, 255,
                                          cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

                    image[0:480, 0:640] = final
                    final = image

                    if score < 0.9 and not isCurrentLap:
                        lap = lap + 1
                        lapCurrentTime = datetime.datetime.now()
                        lapTime = lapCurrentTime - previousLapTime
                        lapTime = float(str(lapTime.total_seconds()))

                        previousLapTime = lapCurrentTime

                        speed = (self.circuitDistance / lapTime) * 3.6

                        lapTimesInSeconds.append(lapTime)
                        speeds.append(speed)

                        if len(lapTimesInSeconds) > 2:

                            plotLapTime = lapTimesInSeconds[1:]
                            plotSpeed = speeds[1:]

                            self.createPlot(plotLapTime, plotSpeed)
                            # print ("Writing new plot! Lap: " + str(len(lapTimesInSeconds)))

                            # canvas.draw()
                            # image = canvas.buffer_rgba()
                            # image = numpy.asarray(image)
                            # image = cv2.cvtColor(image, cv2.COLOR_RGBA2RGB)
                            # plot = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                            # plot = cv2.resize(plot, (1024,768))

                            # cv2.imwrite("/home/pablo/Documents/Datasets/LapTimeRC/"+str(len(lapTimesInSeconds))+".png", plot)

                        sessionDetails = TrainingSessionDetails(session=self.trainingSession, lapNumber=lap, lapTime=lapTime, speed=speed)
                        sessionDetails.save()

                        # with open(self.saveCSV, mode='a') as csvLapTime:
                        #     writer = csv.writer(csvLapTime, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
                        #     writer.writerow([str(datetime.datetime.now()), str(lap), str(lapTime), str(speed)])

                        print("Lap " + str(lap) + ": " + str(datetime.datetime.now()) + " - Total Time: " + str(
                            lapTime) + " - Speed:" + str(speed) + " - Camera FPS:" + str(self.cameraFPS))
                        isCurrentLap = True

                    if isCurrentLap:
                        isCurrentLapCounter = isCurrentLapCounter + 1
                        # print ("CurrentLap Counter:" + str(isCurrentLapCounter))

                    if isCurrentLapCounter > self.minimumLapTime * self.cameraFPS:
                        isCurrentLap = False
                        isCurrentLapCounter = 0

                    # print ("score:" + str(score))
                else:
                    final = frame

                if not initialConfig:
                    currentFrame = currentFrame + 1

                if currentFrame > self.initialConfigTime * self.cameraFPS or currentFrame == 1:
                    initialConfig = True

                if initialConfig:
                    firstImage = frame

        finally:
            print('ended')

    def createPlot(self, plotLapTime, plotSpeed):

        plotRange = range(len(plotLapTime))

        fig = Figure()
        axs = fig.subplots(2,1)
        #ax.plot([1, 2])
        # Save it to a temporary buffer.
        
       
        "plt.clf()"
        #fig, axs = plt.subplots(2, 1)
        rect1 = axs[0].plot(plotRange, plotLapTime)
        axs[0].set_title('Lap Time (s)')

        # zip joins x and y coordinates in pairs
        for x, y in zip(plotRange, plotLapTime):
            label = "{:.2f}".format(y)

            axs[0].annotate(label,  # this is the text
                            (x, y),  # this is the point to label
                            textcoords="offset points",  # how to position the text
                            xytext=(0, 10),  # distance from text to points (x,y)
                            ha='center')  # horizontal alignment can be left, right or center

        rect1 = axs[1].plot(plotRange, plotSpeed)

        # zip joins x and y coordinates in pairs
        for x, y in zip(plotRange, plotSpeed):
            label = "{:.2f}".format(y)

            axs[1].annotate(label,  # this is the text
                            (x, y),  # this is the point to label
                            textcoords="offset points",  # how to position the text
                            xytext=(0, 10),  # distance from text to points (x,y)
                            ha='center')  # horizontal alignment can be left, right or center

        axs[1].set_title('Speed (Km/h)')

        # fig.set_size_inches(10.0, 5)
        fig.tight_layout(pad=1.0)

        #buf = BytesIO()
       # fig.savefig(buf, format="png")
       
        
        fig.savefig(self.saveImg + "/currentPlot.png")

    def get_id(self):

        # returns id of the respective thread
        if hasattr(self, '_thread_id'):
            return self._thread_id
        for id, thread in threading._active.items():
            if thread is self:
                return id

    def raise_exception(self):
        self.stopCamera()
        thread_id = self.get_id()
        res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id,
                                                         ctypes.py_object(SystemExit))
        if res > 1:
            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, 0)
            print('Exception raise failure')
