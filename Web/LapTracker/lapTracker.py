from django.conf import settings
import cv2
import matplotlib.pyplot as plt
import numpy

from skimage.metrics import structural_similarity
import os

import datetime

import csv

import threading
import ctypes
import time

class LapTracker(threading.Thread):

    cameraFPS = 30  # FPS of the camera
    minimumLapTime = 2  # Minimum lap time in seconds
    initialConfigTime = 2  # Minimum time for initial calibration in seconds
    circuitDistance = 12  # distance of the track in meters

    videoDevice = 0 # ID of the camera used by the system

    finalImageSize = (1024, 768)  # Size of the final image generated by the demo

    saveCSV = settings.BASE_DIR + settings.STATIC_URL + "sessions/" + str(datetime.datetime.now()) + ".csv"
    saveImg = settings.BASE_DIR + settings.STATIC_URL + "sessions/"



    cap = None
    def __init__(self, carName="", trackDistance=12):
        self.circuitDistance = float(trackDistance)
        self.cap = cv2.VideoCapture(self.videoDevice)

        self.saveCSV = settings.BASE_DIR + settings.STATIC_URL + "sessions/"+str(carName)+"_" + str(datetime.datetime.now()) + ".csv"

        settings.CURRENT_FILE_NAME = self.saveCSV
        threading.Thread.__init__(self)

    def run(self):
        # target function of the thread class
        try:
            with open(self.saveCSV, mode='w') as csvLapTime:
                writer = csv.writer(csvLapTime, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
                writer.writerow(['Date', 'Lap Number', 'Lap Time (s)', "Speed (Km/h)"])

            # cap.set(cv2.CAP_PROP_AUTOFOCUS, 0) # turn the autofocus off

            # cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0) # set auto exposure

            firstImage = []

            initialConfig = False
            currentFrame = 0
            lap = 0
            isCurrentLap = False
            isCurrentLapCounter = 0
            previousLapTime = datetime.datetime.now()

            lapTimesInSeconds = []
            speeds = []

            while (not settings.STOP_THREAD):

                # Capture frame-by-frame
                ret, frame = self.cap.read()

                # create display image and copy the captured frame to it
                image = numpy.zeros((self.finalImageSize[1], self.finalImageSize[0]), numpy.uint8)

                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

                if len(firstImage) > 0 and initialConfig:
                    (score, diff) = structural_similarity(frame, firstImage, full=True)
                    diff = (diff * 255).astype("uint8")
                    final = cv2.threshold(diff, 0, 255,
                                          cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

                    image[0:480, 0:640] = final
                    final = image

                    if score < 0.9 and not isCurrentLap:
                        lap = lap + 1
                        lapCurrentTime = datetime.datetime.now()
                        lapTime = lapCurrentTime - previousLapTime
                        lapTime = float(str(lapTime.total_seconds()))

                        previousLapTime = lapCurrentTime

                        speed = (self.circuitDistance / lapTime) * 3.6

                        lapTimesInSeconds.append(lapTime)
                        speeds.append(speed)

                        if len(lapTimesInSeconds) > 2:

                            plotLapTime = lapTimesInSeconds[1:]
                            plotSpeed = speeds[1:]
                            plotRange = range(len(plotLapTime))

                            plt.clf()
                            fig, axs = plt.subplots(2, 1)
                            rect1 = axs[0].plot(plotRange, plotLapTime)
                            axs[0].set_title('Lap Time (s)')

                            # zip joins x and y coordinates in pairs
                            for x, y in zip(plotRange, plotLapTime):
                                label = "{:.2f}".format(y)

                                axs[0].annotate(label,  # this is the text
                                                (x, y),  # this is the point to label
                                                textcoords="offset points",  # how to position the text
                                                xytext=(0, 10),  # distance from text to points (x,y)
                                                ha='center')  # horizontal alignment can be left, right or center

                            rect1 = axs[1].plot(plotRange, plotSpeed)

                            # zip joins x and y coordinates in pairs
                            for x, y in zip(plotRange, plotSpeed):
                                label = "{:.2f}".format(y)

                                axs[1].annotate(label,  # this is the text
                                                (x, y),  # this is the point to label
                                                textcoords="offset points",  # how to position the text
                                                xytext=(0, 10),  # distance from text to points (x,y)
                                                ha='center')  # horizontal alignment can be left, right or center

                            axs[1].set_title('Speed (Km/h)')
                            fig.tight_layout(pad=1.0)

                            plt.savefig(self.saveImg + "/currentPlot.png")
                            # print ("Writing new plot! Lap: " + str(len(lapTimesInSeconds)))

                            # canvas.draw()
                            # image = canvas.buffer_rgba()
                            # image = numpy.asarray(image)
                            # image = cv2.cvtColor(image, cv2.COLOR_RGBA2RGB)
                            # plot = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                            # plot = cv2.resize(plot, (1024,768))

                            # cv2.imwrite("/home/pablo/Documents/Datasets/LapTimeRC/"+str(len(lapTimesInSeconds))+".png", plot)

                        with open(self.saveCSV, mode='a') as csvLapTime:
                            writer = csv.writer(csvLapTime, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
                            writer.writerow([str(datetime.datetime.now()), str(lap), str(lapTime), str(speed)])

                        print("Lap " + str(lap) + ": " + str(datetime.datetime.now()) + " - Total Time: " + str(
                            lapTime) + " - Speed:" + str(speed))
                        isCurrentLap = True

                    if isCurrentLap:
                        isCurrentLapCounter = isCurrentLapCounter + 1
                        # print ("CurrentLap Counter:" + str(isCurrentLapCounter))

                    if isCurrentLapCounter > self.minimumLapTime * self.cameraFPS:
                        isCurrentLap = False
                        isCurrentLapCounter = 0

                    # print ("score:" + str(score))
                else:
                    final = frame

                if not initialConfig:
                    currentFrame = currentFrame + 1

                if currentFrame > self.initialConfigTime * self.cameraFPS or currentFrame == 1:
                    initialConfig = True

                if initialConfig:
                    firstImage = frame




        finally:
            print('ended')

    def get_id(self):

        # returns id of the respective thread
        if hasattr(self, '_thread_id'):
            return self._thread_id
        for id, thread in threading._active.items():
            if thread is self:
                return id

    def raise_exception(self):
        self.cap.release()
        thread_id = self.get_id()
        res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id,
                                                         ctypes.py_object(SystemExit))
        if res > 1:
            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, 0)
            print('Exception raise failure')
